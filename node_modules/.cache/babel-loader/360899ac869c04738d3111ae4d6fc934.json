{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\n\nvar ExponentialBackoff =\n/** @class */\nfunction () {\n  function ExponentialBackoff(\n  /**\n   * The initial delay (used as the base delay on the first retry attempt).\n   * Note that jitter will still be applied, so the actual delay could be as\n   * little as 0.5*initialDelayMs.\n   */\n  initialDelayMs,\n  /**\n   * The multiplier to use to determine the extended base delay after each\n   * attempt.\n   */\n  backoffFactor,\n  /**\n   * The maximum base delay after which no further backoff is performed.\n   * Note that jitter will still be applied, so the actual delay could be as\n   * much as 1.5*maxDelayMs.\n   */\n  maxDelayMs) {\n    this.initialDelayMs = initialDelayMs;\n    this.backoffFactor = backoffFactor;\n    this.maxDelayMs = maxDelayMs;\n    this.reset();\n  }\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n\n\n  ExponentialBackoff.prototype.reset = function () {\n    this.currentBaseMs = 0;\n  };\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n\n\n  ExponentialBackoff.prototype.resetToMax = function () {\n    this.currentBaseMs = this.maxDelayMs;\n  };\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts.\n   */\n\n\n  ExponentialBackoff.prototype.backoffAndWait = function () {\n    var def = new Deferred(); // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n\n    var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n\n    if (this.currentBaseMs > 0) {\n      log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" + (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n    }\n\n    setTimeout(function () {\n      def.resolve();\n    }, delayWithJitterMs); // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n\n    this.currentBaseMs *= this.backoffFactor;\n\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n\n    return def.promise;\n  };\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n\n\n  ExponentialBackoff.prototype.jitterDelayMs = function () {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  };\n\n  return ExponentialBackoff;\n}();\n\nexport { ExponentialBackoff };","map":null,"metadata":{},"sourceType":"module"}
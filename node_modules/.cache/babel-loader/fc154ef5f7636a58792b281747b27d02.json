{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbTarget, DbTargetDocument, DbTargetGlobal } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n\nvar IndexedDbQueryCache =\n/** @class */\nfunction () {\n  function IndexedDbQueryCache(serializer) {\n    this.serializer = serializer;\n    /**\n     * The last received snapshot version. We store this seperately from the\n     * metadata to avoid the extra conversion to/from DbTimestamp.\n     */\n\n    this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n    /**\n     * A cached copy of the metadata for the query cache.\n     */\n\n    this.metadata = new DbTargetGlobal(\n    /*highestTargetId=*/\n    0,\n    /*lastListenSequenceNumber=*/\n    0, SnapshotVersion.MIN.toTimestamp());\n    /** The garbage collector to notify about potential garbage keys. */\n\n    this.garbageCollector = null;\n  }\n\n  IndexedDbQueryCache.prototype.start = function (transaction) {\n    var _this = this;\n\n    return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function (metadata) {\n      if (metadata !== null) {\n        _this.metadata = metadata;\n        var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n        _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n      }\n\n      return PersistencePromise.resolve();\n    });\n  };\n\n  IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n    return this.metadata.highestTargetId;\n  };\n\n  IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n    return this.lastRemoteSnapshotVersion;\n  };\n\n  IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n    return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n  };\n\n  IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n    var _this = this;\n\n    var targetId = queryData.targetId;\n    var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n\n    if (targetId > this.metadata.highestTargetId) {\n      this.metadata.highestTargetId = targetId;\n      return addedQueryPromise.next(function () {\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);\n      });\n    } else {\n      return addedQueryPromise;\n    }\n  };\n\n  IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n    return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {\n      targetsStore(transaction).delete(queryData.targetId);\n    });\n  };\n\n  IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n    var _this = this; // Iterating by the canonicalId may yield more than one result because\n    // canonicalId values are not required to be unique per target. This query\n    // depends on the queryTargets index to be efficent.\n\n\n    var canonicalId = query.canonicalId();\n    var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n    var result = null;\n    return targetsStore(transaction).iterate({\n      range: range,\n      index: DbTarget.queryTargetsIndexName\n    }, function (key, value, control) {\n      var found = _this.serializer.fromDbTarget(value); // After finding a potential match, check that the query is\n      // actually equal to the requested query.\n\n\n      if (query.equals(found.query)) {\n        result = found;\n        control.done();\n      }\n    }).next(function () {\n      return result;\n    });\n  };\n\n  IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n    // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // Indexeddb.\n    var promises = [];\n    var store = documentTargetStore(txn);\n    keys.forEach(function (key) {\n      var path = EncodedResourcePath.encode(key.path);\n      promises.push(store.put(new DbTargetDocument(targetId, path)));\n    });\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n    var _this = this; // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n    // IndexedDb.\n\n\n    var promises = [];\n    var store = documentTargetStore(txn);\n    keys.forEach(function (key) {\n      var path = EncodedResourcePath.encode(key.path);\n      promises.push(store.delete([targetId, path]));\n\n      if (_this.garbageCollector !== null) {\n        _this.garbageCollector.addPotentialGarbageKey(key);\n      }\n    });\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n    var store = documentTargetStore(txn);\n    var range = IDBKeyRange.bound([targetId], [targetId + 1],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    return this.notifyGCForRemovedKeys(txn, range).next(function () {\n      return store.delete(range);\n    });\n  };\n\n  IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n    var _this = this;\n\n    var store = documentTargetStore(txn);\n\n    if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n      // In order to generate garbage events properly, we need to read these\n      // keys before deleting.\n      return store.iterate({\n        range: range,\n        keysOnly: true\n      }, function (key, _, control) {\n        var path = EncodedResourcePath.decode(key[1]);\n        var docKey = new DocumentKey(path); // Paranoid assertion in case the the collector is set to null\n        // during the iteration.\n\n        assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n\n        _this.garbageCollector.addPotentialGarbageKey(docKey);\n      });\n    } else {\n      return PersistencePromise.resolve();\n    }\n  };\n\n  IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n    var promises = [];\n    var range = IDBKeyRange.bound([targetId], [targetId + 1],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    var store = documentTargetStore(txn);\n    var result = documentKeySet();\n    return store.iterate({\n      range: range,\n      keysOnly: true\n    }, function (key, _, control) {\n      var path = EncodedResourcePath.decode(key[1]);\n      var docKey = new DocumentKey(path);\n      result = result.add(docKey);\n    }).next(function () {\n      return result;\n    });\n  };\n\n  IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n    this.garbageCollector = gc;\n  };\n\n  IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n    assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n    var path = EncodedResourcePath.encode(key.path);\n    var range = IDBKeyRange.bound([path], [immediateSuccessor(path)],\n    /*lowerOpen=*/\n    false,\n    /*upperOpen=*/\n    true);\n    var count = 0;\n    return documentTargetStore(txn).iterate({\n      index: DbTargetDocument.documentTargetsIndex,\n      keysOnly: true,\n      range: range\n    }, function (key, _, control) {\n      count++;\n      control.done();\n    }).next(function () {\n      return count > 0;\n    });\n  };\n\n  return IndexedDbQueryCache;\n}();\n\nexport { IndexedDbQueryCache };\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\n\nfunction targetsStore(txn) {\n  return getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\n\n\nfunction globalTargetStore(txn) {\n  return getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\n\n\nfunction documentTargetStore(txn) {\n  return getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\n\n\nfunction getStore(txn, store) {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { DbMutationBatch, DbNoDocument, DbRemoteDocument, DbTarget, DbTimestamp } from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n/** Serializer for values stored in the LocalStore. */\n\nvar LocalSerializer =\n/** @class */\nfunction () {\n  function LocalSerializer(remoteSerializer) {\n    this.remoteSerializer = remoteSerializer;\n  }\n  /** Decodes a remote document from storage locally to a Document. */\n\n\n  LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n    if (remoteDoc.document) {\n      return this.remoteSerializer.fromDocument(remoteDoc.document);\n    } else if (remoteDoc.noDocument) {\n      var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n      var readTime = remoteDoc.noDocument.readTime;\n      var timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n      return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n    } else {\n      return fail('Unexpected DbRemoteDocument');\n    }\n  };\n  /** Encodes a document for storage locally. */\n\n\n  LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n    if (maybeDoc instanceof Document) {\n      var doc = this.remoteSerializer.toDocument(maybeDoc);\n      return new DbRemoteDocument(null, doc);\n    } else {\n      var path = maybeDoc.key.path.toArray();\n      var timestamp = maybeDoc.version.toTimestamp();\n      var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n      return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n    }\n  };\n  /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n\n\n  LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n    var _this = this;\n\n    var serializedMutations = batch.mutations.map(function (m) {\n      return _this.remoteSerializer.toMutation(m);\n    });\n    return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n  };\n  /** Decodes a DbMutationBatch into a MutationBatch */\n\n\n  LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n    var _this = this;\n\n    var mutations = dbBatch.mutations.map(function (m) {\n      return _this.remoteSerializer.fromMutation(m);\n    });\n    var timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n    return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n  };\n  /** Decodes a DbTarget into QueryData */\n\n\n  LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n    var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n    var version = SnapshotVersion.fromTimestamp(readTime);\n    var query;\n\n    if (isDocumentQuery(dbTarget.query)) {\n      query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n    } else {\n      query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n    }\n\n    return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n  };\n  /** Encodes QueryData into a DbTarget for storage locally. */\n\n\n  LocalSerializer.prototype.toDbTarget = function (queryData) {\n    assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' + QueryPurpose.Listen + ' may be stored, got ' + queryData.purpose);\n    var timestamp = queryData.snapshotVersion.toTimestamp();\n    var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n    var queryProto;\n\n    if (queryData.query.isDocumentQuery()) {\n      queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n    } else {\n      queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n    }\n\n    assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n    var resumeToken = queryData.resumeToken; // lastListenSequenceNumber is always 0 until we do real GC.\n\n    return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n  };\n\n  return LocalSerializer;\n}();\n\nexport { LocalSerializer };\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\n\nfunction isDocumentQuery(dbQuery) {\n  return dbQuery.documents !== undefined;\n}","map":null,"metadata":{},"sourceType":"module"}
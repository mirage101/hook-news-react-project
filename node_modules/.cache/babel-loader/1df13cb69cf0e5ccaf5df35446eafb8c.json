{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc'; // A RegExp matching ISO 8601 UTC timestamps with optional fraction.\n\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\nvar Timestamp =\n/** @class */\nfunction () {\n  function Timestamp(seconds, nanos) {\n    this.seconds = seconds;\n    this.nanos = nanos;\n    assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n    assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos); // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n\n    assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds); // This will break in the year 10,000.\n\n    assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n  }\n\n  Timestamp.now = function () {\n    return Timestamp.fromEpochMilliseconds(Date.now());\n  };\n\n  Timestamp.fromDate = function (date) {\n    return Timestamp.fromEpochMilliseconds(date.getTime());\n  };\n\n  Timestamp.fromEpochMilliseconds = function (milliseconds) {\n    var seconds = Math.floor(milliseconds / 1000);\n    var nanos = (milliseconds - seconds * 1000) * 1e6;\n    return new Timestamp(seconds, nanos);\n  };\n\n  Timestamp.fromISOString = function (utc) {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n    // Parse the nanos right out of the string.\n    var nanos = 0;\n    var fraction = isoRegExp.exec(utc);\n    assert(!!fraction, 'invalid timestamp: ' + utc);\n\n    if (fraction[1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      var nanoStr = fraction[1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = parseInt(nanoStr, 10);\n    } // Parse the date to get the seconds.\n\n\n    var date = new Date(utc);\n    var seconds = Math.floor(date.getTime() / 1000);\n    return new Timestamp(seconds, nanos);\n  };\n\n  Timestamp.prototype.toDate = function () {\n    return new Date(this.toEpochMilliseconds());\n  };\n\n  Timestamp.prototype.toEpochMilliseconds = function () {\n    return this.seconds * 1000 + this.nanos / 1e6;\n  };\n\n  Timestamp.prototype.compareTo = function (other) {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanos, other.nanos);\n    }\n\n    return primitiveComparator(this.seconds, other.seconds);\n  };\n\n  Timestamp.prototype.equals = function (other) {\n    return other.seconds === this.seconds && other.nanos === this.nanos;\n  };\n\n  Timestamp.prototype.toString = function () {\n    return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n  };\n\n  return Timestamp;\n}();\n\nexport { Timestamp };","map":null,"metadata":{},"sourceType":"module"}
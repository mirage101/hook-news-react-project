{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ObjectMap } from '../util/obj_map';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\n\nvar MemoryQueryCache =\n/** @class */\nfunction () {\n  function MemoryQueryCache() {\n    /**\n     * Maps a query to the data about that query\n     */\n    this.queries = new ObjectMap(function (q) {\n      return q.canonicalId();\n    });\n    /** The last received snapshot version. */\n\n    this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n    /** The highest numbered target ID encountered. */\n\n    this.highestTargetId = 0;\n    /**\n     * A ordered bidirectional mapping between documents and the remote target\n     * IDs.\n     */\n\n    this.references = new ReferenceSet();\n  }\n\n  MemoryQueryCache.prototype.start = function (transaction) {\n    // Nothing to do.\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n    return this.lastRemoteSnapshotVersion;\n  };\n\n  MemoryQueryCache.prototype.getHighestTargetId = function () {\n    return this.highestTargetId;\n  };\n\n  MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n    this.lastRemoteSnapshotVersion = snapshotVersion;\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n    this.queries.set(queryData.query, queryData);\n    var targetId = queryData.targetId;\n\n    if (targetId > this.highestTargetId) {\n      this.highestTargetId = targetId;\n    }\n\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n    this.queries.delete(queryData.query);\n    this.references.removeReferencesForId(queryData.targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n    var queryData = this.queries.get(query) || null;\n    return PersistencePromise.resolve(queryData);\n  };\n\n  MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n    this.references.addReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n    this.references.removeReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n    this.references.removeReferencesForId(targetId);\n    return PersistencePromise.resolve();\n  };\n\n  MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n    var matchingKeys = this.references.referencesForId(targetId);\n    return PersistencePromise.resolve(matchingKeys);\n  };\n\n  MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n    this.references.setGarbageCollector(gc);\n  };\n\n  MemoryQueryCache.prototype.containsKey = function (txn, key) {\n    return this.references.containsKey(txn, key);\n  };\n\n  return MemoryQueryCache;\n}();\n\nexport { MemoryQueryCache };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbDocumentMutation, DbMutationBatch, DbMutationQueue } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n/** A mutation queue for a specific user, backed by IndexedDB. */\n\nvar IndexedDbMutationQueue =\n/** @class */\nfunction () {\n  function IndexedDbMutationQueue(\n  /**\n   * The normalized userId (e.g. null UID => \"\" userId) used to store /\n   * retrieve mutations.\n   */\n  userId, serializer) {\n    this.userId = userId;\n    this.serializer = serializer;\n    this.garbageCollector = null;\n  }\n  /**\n   * Creates a new mutation queue for the given user.\n   * @param user The user for which to create a mutation queue.\n   * @param serializer The serializer to use when persisting to IndexedDb.\n   */\n\n\n  IndexedDbMutationQueue.forUser = function (user, serializer) {\n    // TODO(mcg): Figure out what constraints there are on userIDs\n    // In particular, are there any reserved characters? are empty ids allowed?\n    // For the moment store these together in the same mutations table assuming\n    // that empty userIDs aren't allowed.\n    assert(user.uid !== '', 'UserID must not be an empty string.');\n    var userId = user.isUnauthenticated() ? '' : user.uid;\n    return new IndexedDbMutationQueue(userId, serializer);\n  };\n\n  IndexedDbMutationQueue.prototype.start = function (transaction) {\n    var _this = this;\n\n    return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction).next(function (nextBatchId) {\n      _this.nextBatchId = nextBatchId;\n      return mutationQueuesStore(transaction).get(_this.userId);\n    }).next(function (metadata) {\n      if (!metadata) {\n        metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN,\n        /*lastStreamToken=*/\n        '');\n      }\n\n      _this.metadata = metadata; // On restart, nextBatchId may end up lower than\n      // lastAcknowledgedBatchId since it's computed from the queue\n      // contents, and there may be no mutations in the queue. In this\n      // case, we need to reset lastAcknowledgedBatchId (which is safe\n      // since the queue must be empty).\n\n      if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n        return _this.checkEmpty(transaction).next(function (empty) {\n          assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n          _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n          return mutationQueuesStore(transaction).put(_this.metadata);\n        });\n      } else {\n        return PersistencePromise.resolve();\n      }\n    });\n  };\n  /**\n   * Returns one larger than the largest batch ID that has been stored. If there\n   * are no mutations returns 0. Note that batch IDs are global.\n   */\n\n\n  IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n    var maxBatchId = BATCHID_UNKNOWN;\n    return mutationsStore(txn).iterate({\n      reverse: true\n    }, function (key, batch, control) {\n      var userId = key[0],\n          batchId = key[1];\n\n      if (batchId > maxBatchId) {\n        maxBatchId = batch.batchId;\n      }\n\n      if (userId === '') {\n        // We can't compute a predecessor for the empty string, since it\n        // is lexographically first. That also means that no other\n        // userIds can come before this one, so we can just exit early.\n        control.done();\n      } else {\n        var nextUser = immediatePredecessor(userId);\n        control.skip([nextUser]);\n      }\n    }).next(function () {\n      return maxBatchId + 1;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n    var empty = true;\n    var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n    return mutationsStore(transaction).iterate({\n      range: range\n    }, function (key, value, control) {\n      empty = false;\n      control.done();\n    }).next(function () {\n      return empty;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.nextBatchId);\n  };\n\n  IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n    return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n  };\n\n  IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n    var batchId = batch.batchId;\n    assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n    this.metadata.lastAcknowledgedBatchId = batchId;\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  };\n\n  IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n    return PersistencePromise.resolve(this.metadata.lastStreamToken);\n  };\n\n  IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n    this.metadata.lastStreamToken = validateStreamToken(streamToken);\n    return mutationQueuesStore(transaction).put(this.metadata);\n  };\n\n  IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n    var _this = this;\n\n    var batchId = this.nextBatchId;\n    this.nextBatchId++;\n    var batch = new MutationBatch(batchId, localWriteTime, mutations);\n    var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n    return mutationsStore(transaction).put(dbBatch).next(function () {\n      var promises = [];\n\n      for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n        var mutation = mutations_1[_i];\n        var encodedPath = EncodedResourcePath.encode(mutation.key.path);\n        var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n        documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER);\n      }\n\n      return PersistencePromise.waitFor(promises);\n    }).next(function () {\n      return batch;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n    var _this = this;\n\n    return mutationsStore(transaction).get(this.keyForBatchId(batchId)).next(function (dbBatch) {\n      return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n    var _this = this;\n\n    var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));\n    var foundBatch = null;\n    return mutationsStore(transaction).iterate({\n      range: range\n    }, function (key, dbBatch, control) {\n      if (dbBatch.userId === _this.userId) {\n        assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);\n        foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n      }\n\n      control.done();\n    }).next(function () {\n      return foundBatch;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n    var _this = this;\n\n    var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n    return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {\n      return dbBatches.map(function (dbBatch) {\n        return _this.serializer.fromDbMutationBatch(dbBatch);\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n    var _this = this;\n\n    var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n    return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {\n      return dbBatches.map(function (dbBatch) {\n        return _this.serializer.fromDbMutationBatch(dbBatch);\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n    var _this = this; // Scan the document-mutation index starting with a prefix starting with\n    // the given documentKey.\n\n\n    var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n    var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n    var results = [];\n    return documentMutationsStore(transaction).iterate({\n      range: indexStart\n    }, function (indexKey, _, control) {\n      var userID = indexKey[0],\n          encodedPath = indexKey[1],\n          batchID = indexKey[2]; // Only consider rows matching exactly the specific key of\n      // interest. Note that because we order by path first, and we\n      // order terminators before path separators, we'll encounter all\n      // the index rows for documentKey contiguously. In particular, all\n      // the rows for documentKey will occur before any rows for\n      // documents nested in a subcollection beneath documentKey so we\n      // can stop as soon as we hit any such row.\n\n      var path = EncodedResourcePath.decode(encodedPath);\n\n      if (userID !== _this.userId || !documentKey.path.equals(path)) {\n        control.done();\n        return;\n      }\n\n      var mutationKey = _this.keyForBatchId(batchID); // Look up the mutation batch in the store.\n      // PORTING NOTE: because iteration is callback driven in the web,\n      // we just look up the key instead of keeping an open iterator\n      // like iOS.\n\n\n      return mutationsStore(transaction).get(mutationKey).next(function (dbBatch) {\n        if (dbBatch === null) {\n          fail('Dangling document-mutation reference found: ' + indexKey + ' which points to ' + mutationKey);\n        }\n\n        results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n      });\n    }).next(function () {\n      return results;\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n    var _this = this;\n\n    assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n    var queryPath = query.path;\n    var immediateChildrenLength = queryPath.length + 1; // TODO(mcg): Actually implement a single-collection query\n    //\n    // This is actually executing an ancestor query, traversing the whole\n    // subtree below the collection which can be horrifically inefficient for\n    // some structures. The right way to solve this is to implement the full\n    // value index, but that's not in the cards in the near future so this is\n    // the best we can do for the moment.\n    //\n    // Since we don't yet index the actual properties in the mutations, our\n    // current approach is to just return all mutation batches that affect\n    // documents in the collection being queried.\n\n    var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\n    var encodedQueryPath = indexPrefix[1];\n    var indexStart = IDBKeyRange.lowerBound(indexPrefix); // Collect up unique batchIDs encountered during a scan of the index. Use a\n    // SortedSet to accumulate batch IDs so they can be traversed in order in a\n    // scan of the main table.\n\n    var uniqueBatchIDs = new SortedSet(primitiveComparator);\n    return documentMutationsStore(transaction).iterate({\n      range: indexStart\n    }, function (indexKey, _, control) {\n      var userID = indexKey[0],\n          encodedPath = indexKey[1],\n          batchID = indexKey[2];\n      var path = EncodedResourcePath.decode(encodedPath);\n\n      if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n        control.done();\n        return;\n      } // Rows with document keys more than one segment longer than the\n      // query path can't be matches. For example, a query on 'rooms'\n      // can't match the document /rooms/abc/messages/xyx.\n      // TODO(mcg): we'll need a different scanner when we implement\n      // ancestor queries.\n\n\n      if (path.length !== immediateChildrenLength) {\n        return;\n      }\n\n      uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n    }).next(function () {\n      var results = [];\n      var promises = []; // TODO(rockwood): Implement this using iterate.\n\n      uniqueBatchIDs.forEach(function (batchID) {\n        var mutationKey = _this.keyForBatchId(batchID);\n\n        promises.push(mutationsStore(transaction).get(mutationKey).next(function (mutation) {\n          if (mutation === null) {\n            fail('Dangling document-mutation reference found, ' + 'which points to ' + mutationKey);\n          }\n\n          results.push(_this.serializer.fromDbMutationBatch(mutation));\n        }));\n      });\n      return PersistencePromise.waitFor(promises).next(function () {\n        return results;\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n    var txn = mutationsStore(transaction);\n    var indexTxn = documentMutationsStore(transaction);\n    var promises = [];\n\n    var _loop_1 = function _loop_1(batch) {\n      var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n      var numDeleted = 0;\n      var removePromise = txn.iterate({\n        range: range\n      }, function (key, value, control) {\n        numDeleted++;\n        return control.delete();\n      });\n      promises.push(removePromise.next(function () {\n        assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' + batch.batchId);\n      }));\n\n      for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n        var mutation = _a[_i];\n        var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n        promises.push(indexTxn.delete(indexKey));\n\n        if (this_1.garbageCollector !== null) {\n          this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n        }\n      }\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n      var batch = batches_1[_i];\n\n      _loop_1(batch);\n    }\n\n    return PersistencePromise.waitFor(promises);\n  };\n\n  IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n    var _this = this;\n\n    return this.checkEmpty(txn).next(function (empty) {\n      if (!empty) {\n        return PersistencePromise.resolve();\n      } // Verify that there are no entries in the documentMutations index if\n      // the queue is empty.\n\n\n      var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));\n      var danglingMutationReferences = [];\n      return documentMutationsStore(txn).iterate({\n        range: startRange\n      }, function (key, _, control) {\n        var userID = key[0];\n\n        if (userID !== _this.userId) {\n          control.done();\n          return;\n        } else {\n          var path = EncodedResourcePath.decode(key[1]);\n          danglingMutationReferences.push(path);\n        }\n      }).next(function () {\n        assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' + danglingMutationReferences.map(function (p) {\n          return p.canonicalString();\n        }));\n      });\n    });\n  };\n\n  IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n    this.garbageCollector = gc;\n  };\n\n  IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n    var _this = this;\n\n    var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n    var encodedPath = indexKey[1];\n    var startRange = IDBKeyRange.lowerBound(indexKey);\n    var containsKey = false;\n    return documentMutationsStore(txn).iterate({\n      range: startRange,\n      keysOnly: true\n    }, function (key, _, control) {\n      var userID = key[0],\n          keyPath = key[1],\n          batchID = key[2];\n\n      if (userID === _this.userId && keyPath === encodedPath) {\n        containsKey = true;\n      }\n\n      control.done();\n    }).next(function () {\n      return containsKey;\n    });\n  };\n  /**\n   * Creates a [userId, batchId] key for use with the DbMutationQueue object\n   * store.\n   */\n\n\n  IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n    return [this.userId, batchId];\n  };\n\n  return IndexedDbMutationQueue;\n}();\n\nexport { IndexedDbMutationQueue };\n\nfunction validateStreamToken(token) {\n  assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n  return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\n\n\nfunction mutationsStore(txn) {\n  return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\n\n\nfunction documentMutationsStore(txn) {\n  return getStore(txn, DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\n\n\nfunction mutationQueuesStore(txn) {\n  return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\n\n\nfunction getStore(txn, store) {\n  if (txn instanceof SimpleDbTransaction) {\n    return txn.store(store);\n  } else {\n    return fail('Invalid transaction object provided!');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
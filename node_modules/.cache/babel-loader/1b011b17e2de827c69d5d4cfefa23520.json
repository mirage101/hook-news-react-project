{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport * as objUtils from '../util/obj';\nimport { CurrentStatusUpdate, RemoteEvent, ResetMapping, UpdateMapping } from './remote_event';\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\n\nvar DocumentWatchChange =\n/** @class */\nfunction () {\n  function DocumentWatchChange(\n  /** The new document applies to all of these targets. */\n  updatedTargetIds,\n  /** The new document is removed from all of these targets. */\n  removedTargetIds,\n  /** The key of the document for this change. */\n  key,\n  /**\n   * The new document or NoDocument if it was deleted. Is null if the\n   * document went out of view without the server sending a new document.\n   */\n  newDoc) {\n    this.updatedTargetIds = updatedTargetIds;\n    this.removedTargetIds = removedTargetIds;\n    this.key = key;\n    this.newDoc = newDoc;\n  }\n\n  return DocumentWatchChange;\n}();\n\nexport { DocumentWatchChange };\n\nvar ExistenceFilterChange =\n/** @class */\nfunction () {\n  function ExistenceFilterChange(targetId, existenceFilter) {\n    this.targetId = targetId;\n    this.existenceFilter = existenceFilter;\n  }\n\n  return ExistenceFilterChange;\n}();\n\nexport { ExistenceFilterChange };\nexport var WatchTargetChangeState;\n\n(function (WatchTargetChangeState) {\n  WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n  WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState || (WatchTargetChangeState = {}));\n\nvar WatchTargetChange =\n/** @class */\nfunction () {\n  function WatchTargetChange(\n  /** What kind of change occurred to the watch target. */\n  state,\n  /** The target IDs that were added/removed/set. */\n  targetIds,\n  /**\n   * An opaque, server-assigned token that allows watching a query to be\n   * resumed after disconnecting without retransmitting all the data that\n   * matches the query. The resume token essentially identifies a point in\n   * time from which the server should resume sending results.\n   */\n  resumeToken,\n  /** An RPC error indicating why the watch failed. */\n  cause) {\n    if (resumeToken === void 0) {\n      resumeToken = emptyByteString();\n    }\n\n    if (cause === void 0) {\n      cause = null;\n    }\n\n    this.state = state;\n    this.targetIds = targetIds;\n    this.resumeToken = resumeToken;\n    this.cause = cause;\n  }\n\n  return WatchTargetChange;\n}();\n\nexport { WatchTargetChange };\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\n\nvar WatchChangeAggregator =\n/** @class */\nfunction () {\n  function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n    this.snapshotVersion = snapshotVersion;\n    this.listenTargets = listenTargets;\n    /** The existence filter - if any - for the given target IDs. */\n\n    this.existenceFilters = {};\n    /** Keeps track of the current target mappings */\n\n    this.targetChanges = {};\n    /** Keeps track of document to update */\n\n    this.documentUpdates = maybeDocumentMap();\n    /** Whether this aggregator was frozen and can no longer be modified */\n\n    this.frozen = false;\n    this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n  }\n  /** Aggregates a watch change into the current state */\n\n\n  WatchChangeAggregator.prototype.add = function (watchChange) {\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n\n    if (watchChange instanceof DocumentWatchChange) {\n      this.addDocumentChange(watchChange);\n    } else if (watchChange instanceof WatchTargetChange) {\n      this.addTargetChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.addExistenceFilterChange(watchChange);\n    } else {\n      fail('Unknown watch change: ' + watchChange);\n    }\n  };\n  /** Aggregates all provided watch changes to the current state in order */\n\n\n  WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n    var _this = this;\n\n    assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n    watchChanges.forEach(function (change) {\n      return _this.add(change);\n    });\n  };\n  /**\n   * Converts the current state into a remote event with the snapshot version\n   * provided via the constructor.\n   */\n\n\n  WatchChangeAggregator.prototype.createRemoteEvent = function () {\n    var _this = this;\n\n    var targetChanges = this.targetChanges; // Remove all the non-active targets from the remote event.\n\n    objUtils.forEachNumber(this.targetChanges, function (targetId) {\n      if (!_this.isActiveTarget(targetId)) {\n        delete targetChanges[targetId];\n      }\n    }); // Mark this aggregator as frozen so no further modifications are made\n\n    this.frozen = true;\n    return new RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n  };\n\n  WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n    var change = this.targetChanges[targetId];\n\n    if (!change) {\n      // Create an UpdateMapping by default, since resets are always explicit.\n      change = {\n        currentStatusUpdate: CurrentStatusUpdate.None,\n        snapshotVersion: this.snapshotVersion,\n        mapping: new UpdateMapping(),\n        resumeToken: emptyByteString()\n      };\n      this.targetChanges[targetId] = change;\n    }\n\n    return change;\n  };\n  /**\n   * We need to wait for watch to ack targets before we process those events,\n   * so to know if a target is active, there must be no pending acks we're\n   * waiting for and it must be in the current list of targets that the client\n   * cares about.\n   *\n   * This method is visible for testing.\n   */\n\n\n  WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n    return !objUtils.contains(this.pendingTargetResponses, targetId) && objUtils.contains(this.listenTargets, targetId);\n  };\n\n  WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n    var relevant = false;\n\n    for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n      var targetId = _a[_i];\n\n      if (this.isActiveTarget(targetId)) {\n        var change = this.ensureTargetChange(targetId);\n        change.mapping.add(docChange.key);\n        relevant = true;\n      }\n    }\n\n    for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n      var targetId = _c[_b];\n\n      if (this.isActiveTarget(targetId)) {\n        var change = this.ensureTargetChange(targetId);\n        change.mapping.delete(docChange.key);\n        relevant = true;\n      }\n    } // Only update the document if there is a new document to replace to an\n    // active target that is being listened to, this might be just a target\n    // update instead.\n\n\n    if (docChange.newDoc && relevant) {\n      this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n    }\n  };\n\n  WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n    var _this = this;\n\n    targetChange.targetIds.forEach(function (targetId) {\n      var change = _this.ensureTargetChange(targetId);\n\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (_this.isActiveTarget(targetId)) {\n            // Creating the change above satisfies the semantics of no-change.\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          _this.recordTargetResponse(targetId);\n\n          if (!objUtils.contains(_this.pendingTargetResponses, targetId)) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            change.mapping = new UpdateMapping();\n            change.currentStatusUpdate = CurrentStatusUpdate.None;\n            delete _this.existenceFilters[targetId];\n          }\n\n          applyResumeToken(change, targetChange.resumeToken);\n          break;\n\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can\n          // post-filter and remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          _this.recordTargetResponse(targetId);\n\n          assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n          break;\n\n        case WatchTargetChangeState.Current:\n          if (_this.isActiveTarget(targetId)) {\n            change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        case WatchTargetChangeState.Reset:\n          if (_this.isActiveTarget(targetId)) {\n            // Overwrite any existing target mapping with a reset\n            // mapping. Every subsequent update will modify the reset\n            // mapping, not an update mapping.\n            change.mapping = new ResetMapping();\n            applyResumeToken(change, targetChange.resumeToken);\n          }\n\n          break;\n\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  };\n  /**\n   * Record that we get a watch target add/remove by decrementing the number of\n   * pending target responses that we have.\n   */\n\n\n  WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n    var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n\n    if (newCount === 0) {\n      delete this.pendingTargetResponses[targetId];\n    } else {\n      this.pendingTargetResponses[targetId] = newCount;\n    }\n  };\n\n  WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n    if (this.isActiveTarget(change.targetId)) {\n      this.existenceFilters[change.targetId] = change.existenceFilter;\n    }\n  };\n\n  return WatchChangeAggregator;\n}();\n\nexport { WatchChangeAggregator };\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\n\nfunction applyResumeToken(change, resumeToken) {\n  if (resumeToken.length > 0) {\n    change.resumeToken = resumeToken;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
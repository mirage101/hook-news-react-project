{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorCode, EventType, WebChannel, XhrIoPool, createWebChannelTransport } from '@firebase/webchannel-wrapper';\nimport { SDK_VERSION } from '../core/version';\nimport { mapCodeFromHttpStatus, mapCodeFromRpcStatus } from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nvar LOG_TAG = 'Connection';\nvar RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nvar RPC_URL_VERSION = 'v1beta1';\n/** Maps RPC names to the corresponding REST endpoint name. */\n\nvar RPC_NAME_REST_MAPPING = {\n  BatchGetDocuments: 'batchGet',\n  Commit: 'commit'\n}; // TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\n\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\n\nvar WebChannelConnection =\n/** @class */\nfunction () {\n  function WebChannelConnection(info) {\n    this.databaseId = info.databaseId;\n    this.pool = new XhrIoPool();\n    var proto = info.ssl ? 'https' : 'http';\n    this.baseUrl = proto + '://' + info.host;\n  }\n  /**\n   * Modifies the headers for a request, adding any authorization token if\n   * present and any additional headers for the request.\n   */\n\n\n  WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n    if (token) {\n      for (var header in token.authHeaders) {\n        if (token.authHeaders.hasOwnProperty(header)) {\n          headers[header] = token.authHeaders[header];\n        }\n      }\n    }\n\n    headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE; // This header is used to improve routing and project isolation by the\n    // backend.\n\n    headers['google-cloud-resource-prefix'] = \"projects/\" + this.databaseId.projectId + \"/\" + (\"databases/\" + this.databaseId.database);\n  };\n\n  WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {\n    var _this = this;\n\n    var url = this.makeUrl(rpcName);\n    return new Promise(function (resolve, reject) {\n      _this.pool.getObject(function (xhr) {\n        xhr.listenOnce(EventType.COMPLETE, function () {\n          try {\n            switch (xhr.getLastErrorCode()) {\n              case ErrorCode.NO_ERROR:\n                var json = xhr.getResponseJson();\n                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                resolve(json);\n                break;\n\n              case ErrorCode.TIMEOUT:\n                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                break;\n\n              case ErrorCode.HTTP_ERROR:\n                var status_1 = xhr.getStatus();\n                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n\n                if (status_1 > 0) {\n                  reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                } else {\n                  // If we received an HTTP_ERROR but there's no status code,\n                  // it's most probably a connection issue\n                  log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                  reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                }\n\n                break;\n\n              default:\n                fail('RPC \"' + rpcName + '\" failed with unanticipated ' + 'webchannel error ' + xhr.getLastErrorCode() + ': ' + xhr.getLastError() + ', giving up.');\n            }\n          } finally {\n            log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n\n            _this.pool.releaseObject(xhr);\n          }\n        });\n        var requestString = JSON.stringify(request);\n        log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString); // Content-Type: text/plain will avoid preflight requests which might\n        // mess with CORS and redirects by proxies. If we add custom headers\n        // we will need to change this code to potentially use the\n        // $httpOverwrite parameter supported by ESF to avoid\n        // triggering preflight requests.\n\n        var headers = {\n          'Content-Type': 'text/plain'\n        };\n\n        _this.modifyHeadersForRequest(headers, token);\n\n        xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n      });\n    });\n  };\n\n  WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {\n    // The REST API automatically aggregates all of the streamed results, so we\n    // can just use the normal invoke() method.\n    return this.invokeRPC(rpcName, request, token);\n  };\n\n  WebChannelConnection.prototype.openStream = function (rpcName, token) {\n    var urlParts = [this.baseUrl, '/', RPC_STREAM_SERVICE, '/', rpcName, '/channel'];\n    var webchannelTransport = createWebChannelTransport();\n    var request = {\n      // Background channel test avoids the initial two test calls and decreases\n      // initial cold start time.\n      // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n      // we should monitor closely for any reports.\n      backgroundChannelTest: true,\n      // Required for backend stickiness, routing behavior is based on this\n      // parameter.\n      httpSessionIdParam: 'gsessionid',\n      initMessageHeaders: {},\n      // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n      // preflight round-trip. This is formally defined here:\n      // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n      httpHeadersOverwriteParam: '$httpHeaders',\n      sendRawJson: true,\n      supportsCrossDomainXhr: true\n    };\n    this.modifyHeadersForRequest(request.initMessageHeaders, token);\n    var url = urlParts.join('');\n    log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request); // tslint:disable-next-line:no-any Because listen isn't defined on it.\n\n    var channel = webchannelTransport.createWebChannel(url, request); // WebChannel supports sending the first message with the handshake - saving\n    // a network round trip. However, it will have to call send in the same\n    // JS event loop as open. In order to enforce this, we delay actually\n    // opening the WebChannel until send is called. Whether we have called\n    // open is tracked with this variable.\n\n    var opened = false; // A flag to determine whether the stream was closed (by us or through an\n    // error/close event) to avoid delivering multiple close events or sending\n    // on a closed stream\n\n    var closed = false; // tslint:disable-next-line:no-any\n\n    var streamBridge = new StreamBridge({\n      sendFn: function sendFn(msg) {\n        if (!closed) {\n          if (!opened) {\n            log.debug(LOG_TAG, 'Opening WebChannel transport.');\n            channel.open();\n            opened = true;\n          }\n\n          log.debug(LOG_TAG, 'WebChannel sending:', msg);\n          channel.send(msg);\n        } else {\n          log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n        }\n      },\n      closeFn: function closeFn() {\n        return channel.close();\n      }\n    }); // Closure events are guarded and exceptions are swallowed, so catch any\n    // exception and rethrow using a setTimeout so they become visible again.\n    // Note that eventually this function could go away if we are confident\n    // enough the code is exception free.\n\n    var unguardedEventListen = function unguardedEventListen(type, fn) {\n      // TODO(dimond): closure typing seems broken because WebChannel does\n      // not implement goog.events.Listenable\n      channel.listen(type, function (param) {\n        try {\n          fn(param);\n        } catch (e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      });\n    };\n\n    unguardedEventListen(WebChannel.EventType.OPEN, function () {\n      if (!closed) {\n        log.debug(LOG_TAG, 'WebChannel transport opened.');\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.CLOSE, function () {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport closed');\n        streamBridge.callOnClose();\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.ERROR, function (err) {\n      if (!closed) {\n        closed = true;\n        log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n        streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n      }\n    });\n    unguardedEventListen(WebChannel.EventType.MESSAGE, function (msg) {\n      if (!closed) {\n        // WebChannel delivers message events as array. If batching\n        // is not enabled (it's off by default) each message will be\n        // delivered alone, resulting in a single element array.\n        var msgData = msg.data[0];\n        assert(!!msgData, 'Got a webchannel message without data.'); // TODO(b/35143891): There is a bug in One Platform that caused errors\n        // (and only errors) to be wrapped in an extra array. To be forward\n        // compatible with the bug we need to check either condition. The latter\n        // can be removed once the fix has been rolled out.\n\n        var error = msgData.error || msgData[0] && msgData[0].error;\n\n        if (error) {\n          log.debug(LOG_TAG, 'WebChannel received error:', error); // error.status will be a string like 'OK' or 'NOT_FOUND'.\n\n          var status_2 = error.status;\n          var code = mapCodeFromRpcStatus(status_2);\n          var message = error.message;\n\n          if (code === undefined) {\n            code = Code.INTERNAL;\n            message = 'Unknown error status: ' + status_2 + ' with message ' + error.message;\n          } // Mark closed so no further events are propagated\n\n\n          closed = true;\n          streamBridge.callOnClose(new FirestoreError(code, message));\n          channel.close();\n        } else {\n          log.debug(LOG_TAG, 'WebChannel received:', msgData);\n          streamBridge.callOnMessage(msgData);\n        }\n      }\n    });\n    setTimeout(function () {\n      // Technically we could/should wait for the WebChannel opened event,\n      // but because we want to send the first message with the WebChannel\n      // handshake we pretend the channel opened here (asynchronously), and\n      // then delay the actual open until the first message is sent.\n      streamBridge.callOnOpen();\n    }, 0);\n    return streamBridge;\n  }; // visible for testing\n\n\n  WebChannelConnection.prototype.makeUrl = function (rpcName) {\n    var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n    assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n    var url = [this.baseUrl, '/', RPC_URL_VERSION];\n    url.push('/projects/');\n    url.push(this.databaseId.projectId);\n    url.push('/databases/');\n    url.push(this.databaseId.database);\n    url.push('/documents');\n    url.push(':');\n    url.push(urlRpcName);\n    return url.join('');\n  };\n\n  return WebChannelConnection;\n}();\n\nexport { WebChannelConnection };","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { Code, FirestoreError } from '../util/error';\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\n\nvar Transaction =\n/** @class */\nfunction () {\n  function Transaction(datastore) {\n    this.datastore = datastore; // The version of each document that was read during this transaction.\n\n    this.readVersions = documentVersionMap();\n    this.mutations = [];\n    this.committed = false;\n  }\n\n  Transaction.prototype.recordVersion = function (doc) {\n    var docVersion = doc.version;\n\n    if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.forDeletedDoc();\n    }\n\n    var existingVersion = this.readVersions.get(doc.key);\n\n    if (existingVersion !== null) {\n      if (!docVersion.equals(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n      }\n    } else {\n      this.readVersions = this.readVersions.insert(doc.key, docVersion);\n    }\n  };\n\n  Transaction.prototype.lookup = function (keys) {\n    var _this = this;\n\n    if (this.committed) {\n      return Promise.reject('Transaction has already completed.');\n    }\n\n    if (this.mutations.length > 0) {\n      return Promise.reject('Transactions lookups are invalid after writes.');\n    }\n\n    return this.datastore.lookup(keys).then(function (docs) {\n      docs.forEach(function (doc) {\n        return _this.recordVersion(doc);\n      });\n      return docs;\n    });\n  };\n\n  Transaction.prototype.write = function (mutations) {\n    if (this.committed) {\n      throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n    }\n\n    this.mutations = this.mutations.concat(mutations);\n  };\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n\n\n  Transaction.prototype.precondition = function (key) {\n    var version = this.readVersions.get(key);\n\n    if (version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.NONE;\n    }\n  };\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n\n\n  Transaction.prototype.preconditionForUpdate = function (key) {\n    var version = this.readVersions.get(key);\n\n    if (version && version.equals(SnapshotVersion.forDeletedDoc())) {\n      // The document doesn't exist, so fail the transaction.\n      throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n    } else if (version) {\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  };\n\n  Transaction.prototype.set = function (key, data) {\n    this.write(data.toMutations(key, this.precondition(key)));\n  };\n\n  Transaction.prototype.update = function (key, data) {\n    this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n  };\n\n  Transaction.prototype.delete = function (key) {\n    this.write([new DeleteMutation(key, this.precondition(key))]); // Since the delete will be applied before all following writes, we need to\n    // ensure that the precondition for the next write will be exists: false.\n\n    this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());\n  };\n\n  Transaction.prototype.commit = function () {\n    var _this = this;\n\n    var unwritten = this.readVersions; // For each mutation, note that the doc was written.\n\n    this.mutations.forEach(function (mutation) {\n      unwritten = unwritten.remove(mutation.key);\n    });\n\n    if (!unwritten.isEmpty()) {\n      return Promise.reject(Error('Every document read in a transaction must also be written.'));\n    }\n\n    return this.datastore.commit(this.mutations).then(function () {\n      _this.committed = true;\n    });\n  };\n\n  return Transaction;\n}();\n\nexport { Transaction };","map":null,"metadata":{},"sourceType":"module"}
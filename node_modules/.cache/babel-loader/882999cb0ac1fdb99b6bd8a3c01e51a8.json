{"ast":null,"code":"/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet, documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\n\nvar LocalDocumentsView =\n/** @class */\nfunction () {\n  function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n    this.remoteDocumentCache = remoteDocumentCache;\n    this.mutationQueue = mutationQueue;\n  }\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n\n\n  LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n    var _this = this;\n\n    return this.remoteDocumentCache.getEntry(transaction, key).next(function (remoteDoc) {\n      return _this.computeLocalDocument(transaction, key, remoteDoc);\n    });\n  };\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n\n\n  LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n    var _this = this;\n\n    var promises = [];\n    var results = maybeDocumentMap();\n    keys.forEach(function (key) {\n      promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n        // TODO(http://b/32275378): Don't conflate missing / deleted.\n        if (!maybeDoc) {\n          maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n        }\n\n        results = results.insert(key, maybeDoc);\n      }));\n    });\n    return PersistencePromise.waitFor(promises).next(function () {\n      return results;\n    });\n  };\n  /** Performs a query against the local view of all documents. */\n\n\n  LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n    if (DocumentKey.isDocumentKey(query.path)) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(transaction, query);\n    }\n  };\n\n  LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n    // Just do a simple document lookup.\n    return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {\n      var result = documentMap();\n\n      if (maybeDoc instanceof Document) {\n        result = result.insert(maybeDoc.key, maybeDoc);\n      }\n\n      return result;\n    });\n  };\n\n  LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n    var _this = this; // Query the remote documents and overlay mutations.\n    // TODO(mikelehen): There may be significant overlap between the mutations\n    // affecting these remote documents and the\n    // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n\n\n    var results;\n    return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query).next(function (queryResults) {\n      return _this.computeLocalDocuments(transaction, queryResults);\n    }).next(function (promisedResults) {\n      results = promisedResults; // Now use the mutation queue to discover any other documents that may\n      // match the query after applying mutations.\n\n      return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n    }).next(function (matchingMutationBatches) {\n      var matchingKeys = documentKeySet();\n\n      for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n        var batch = matchingMutationBatches_1[_i];\n\n        for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n          var mutation = _b[_a]; // TODO(mikelehen): PERF: Check if this mutation actually\n          // affects the query to reduce work.\n\n          if (!results.get(mutation.key)) {\n            matchingKeys = matchingKeys.add(mutation.key);\n          }\n        }\n      } // Now add in the results for the matchingKeys.\n\n\n      var promises = [];\n      matchingKeys.forEach(function (key) {\n        promises.push(_this.getDocument(transaction, key).next(function (doc) {\n          if (doc instanceof Document) {\n            results = results.insert(doc.key, doc);\n          }\n        }));\n      });\n      return PersistencePromise.waitFor(promises);\n    }).next(function () {\n      // Finally, filter out any documents that don't actually match\n      // the query.\n      results.forEach(function (key, doc) {\n        if (!query.matches(doc)) {\n          results = results.remove(key);\n        }\n      });\n      return results;\n    });\n  };\n  /**\n   * Takes a remote document and applies local mutations to generate the local\n   * view of the document.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the document (necessary when remoteDocument\n   *     is null).\n   * @param document The base remote document to apply mutations to or null.\n   */\n\n\n  LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, documentKey).next(function (batches) {\n      for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n        var batch = batches_1[_i];\n        document = batch.applyToLocalView(documentKey, document);\n      }\n\n      return document;\n    });\n  };\n  /**\n   * Takes a set of remote documents and applies local mutations to generate the\n   * local view of the documents.\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documents The base remote documents to apply mutations to.\n   * @return The local view of the documents.\n   */\n\n\n  LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n    var _this = this;\n\n    var promises = [];\n    documents.forEach(function (key, doc) {\n      promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n        if (mutatedDoc instanceof Document) {\n          documents = documents.insert(mutatedDoc.key, mutatedDoc);\n        } else if (mutatedDoc instanceof NoDocument) {\n          documents = documents.remove(mutatedDoc.key);\n        } else {\n          fail('Unknown MaybeDocument: ' + mutatedDoc);\n        }\n      }));\n    });\n    return PersistencePromise.waitFor(promises).next(function () {\n      return documents;\n    });\n  };\n\n  return LocalDocumentsView;\n}();\n\nexport { LocalDocumentsView };","map":null,"metadata":{},"sourceType":"module"}